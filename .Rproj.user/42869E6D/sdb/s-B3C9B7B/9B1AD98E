{
    "collab_server" : "",
    "contents" : "#------------------------------------------------------------------------------\n# Several functions to handle proteomics data or file formats \n# (C) Sebastian Malchow 2016\n#------------------------------------------------------------------------------\n\n# Reads a *.fasta file an konverts it in an easy to handle format\n# \"file -> F\" a character string with the fiel name or path/filename of the *.fasta to import\n# \"F -> dat\" a dataframe with the columns..., each row for one protein\nreadFasta <- function(file){\n  \n  dat <- read.csv2(file, header = FALSE, as.is = TRUE )\n  \n  dat$proteinName <- dat[,1]\n  dat$proteinSequence <- \"\"\n  \n  proteinRows <- as.numeric(rownames(dat[ grepl(dat$proteinName, pattern = \"^>\" ) ,]))\n  sequenceEnds <- c(proteinRows[-1], nrow(dat) + 1)\n  sequenceLines <- sequenceEnds - proteinRows - 1 \n  maxSequenceLines <- max( sequenceLines )\n  \n  pb <- txtProgressBar(min = 0, max = maxSequenceLines, style = 3)\n  \n  for (i in 1:maxSequenceLines) {\n    proteinRowsSub <- proteinRows[sequenceLines >= i]\n    sequenceLinesSub <- proteinRowsSub + i\n    dat$proteinSequence[proteinRowsSub] <- paste0(dat$proteinSequence[proteinRowsSub], dat$proteinName[sequenceLinesSub]) \n    setTxtProgressBar(pb, i)\n  }\n  \n  dat <- dat[proteinRows,2:3]\n  \n  grepAccession <- function(slice){\n    pos <- unlist(gregexpr(pattern = \"|\", slice, fixed = TRUE))\n    acc <- substring(slice, first = pos[1] + 1, last = pos[2] - 1) \n    return(acc)\n  }\n  \n  grepName <- function(slice){\n    pos <- unlist(gregexpr(pattern = \"|\", slice, fixed = TRUE))\n    pos2 <- unlist(gregexpr(pattern = \" \", slice, fixed = TRUE))\n    prefNam <- substring(slice, first = pos[2] + 1, last = pos2[1] - 1) \n    return(prefNam)\n  }\n  \n  grepRest <- function(slice){\n    pos <- unlist(gregexpr(pattern = \" \", slice, fixed = TRUE))\n    rest <- substring(slice, first = pos[1] + 1)\n    return(rest)\n  }\n  \n  \n  dat$proteinAccession <- sapply(dat$proteinName, grepAccession)\n  dat$proteinPreferredName <- sapply(dat$proteinName, grepName)\n  dat$proteinDetails <- sapply(dat$proteinName, grepRest)\n  dat$proteinLength <- nchar(dat$proteinSequence)\n  \n  return(dat)\n  \n}\n\n# \n# \"data -> F\" \n# \"enzyme -> F\" \n# \"missed -> F\" \n# \"F -> dat\" a dataframe with the columns..., each row for one protein\n# This function is an altered Version of Digest() in OrgMassSpecR !!!\n# The determination of sequence position seems to be off\ndigest <- function(data, enzyme = \"trypsin\", missed = 0) {\n  if (is.data.frame(data)) {sequence <- data$proteinSequence} else {sequence <- data}\n  \n  seq_vector <- strsplit(sequence, split = \"\")[[1]]\n  end_position <- length(seq_vector)\n  if (enzyme == \"trypsin\") {\n    if (seq_vector[end_position] == \"K\" | seq_vector[end_position] == \n        \"R\") {\n      seq_vector[end_position] <- \"!\"\n      seq_string <- paste(seq_vector, collapse = \"\")\n    }\n    else seq_string <- sequence\n    seq_string <- gsub(\"KP\", \"!P\", seq_string)\n    seq_string <- gsub(\"RP\", \"!P\", seq_string)\n    seq_vector <- strsplit(seq_string, split = \"\")[[1]]\n    stop <- grep(\"K|R\", seq_vector)\n    start <- stop + as.integer(1)\n  }\n  if (enzyme == \"trypsin.strict\") {\n    if (seq_vector[end_position] == \"K\" | seq_vector[end_position] == \n        \"R\") {\n      seq_vector[end_position] <- \"!\"\n      seq_string <- paste(seq_vector, collapse = \"\")\n    }\n    else seq_string <- sequence\n    seq_vector <- strsplit(seq_string, split = \"\")[[1]]\n    stop <- grep(\"K|R\", seq_vector)\n    start <- stop + 1\n  }\n  if (enzyme == \"pepsin\") {\n    if (seq_vector[end_position] == \"F\" | seq_vector[end_position] == \n        \"L\" | seq_vector[end_position] == \"W\" | seq_vector[end_position] == \n        \"Y\" | seq_vector[end_position] == \"A\" | seq_vector[end_position] == \n        \"E\" | seq_vector[end_position] == \"Q\") {\n      seq_vector[end_position] <- \"!\"\n    }\n    stop <- grep(\"F|L|W|Y|A|E|Q\", seq_vector)\n    start <- stop + 1\n  }\n  \n  if (enzyme != \"trypsin\" & enzyme != \"trypsin.strict\" & enzyme != \n      \"pepsin\") \n    stop(\"undefined enzyme, defined enzymes are trypsin, trypsin.strict, and pepsin\")\n  \n  if (length(stop) == 0) \n    warning(\"sequence does not contain cleavage sites\")\n  \n  cleave <- function(sequence, start, stop, misses) {\n    peptide <- substring(sequence, start, stop)\n    peptideLength <- nchar(peptide)\n    missedCleavages <- rep(misses, times = length(peptide))\n    previousAA <- substring(sequence, start - 2, start - 1)\n    nextAA <- substring(sequence, stop + 1, stop + 2)\n    result <- data.frame(peptide, start, stop, peptideLength, missedCleavages, previousAA, nextAA, stringsAsFactors = FALSE)\n    return(result)\n  }\n  \n  start <- c(as.integer(1), start)\n  stop <- c(stop, end_position)\n  results <- cleave(sequence, start, stop, 0)\n  \n  if (missed > length(stop)) \n    warning(\"number of specified missed cleavages is greater than the maximum possible\")\n  else if (missed > 0) {\n    for (i in 1:missed) {\n      start_tmp <- start[1:(length(start) - i)]\n      stop_tmp <- stop[(1 + i):length(stop)]\n      peptide <- cleave(sequence, start_tmp, stop_tmp, i)\n      results <- rbind(results, peptide)\n    }\n  }\n  \n  if (is.data.frame(data)) {\n    results[,names(data)] <- data[1,]\n  }\n  \n  return(results)\n}\n\n# Determines the protein group and the the number of proteins in the group for a peptide\n# \"dat -> F\" dataframe of equal peptides but differing protein accessions \n# \"F -> dat\" input dataframe plus protein group and group size\ngetProteinGroup <- function(dat){\n  tmp <- unique(dat$proteinAccession)\n  tmp <- tmp[order(tmp)]\n  dat$proteinGroup <- paste(tmp, collapse = \" \")\n  dat$proteinGroupSize <- length(tmp)\n  return(dat)\n}\n\n# Determines the protein sequence group and the the number of proteins in the group\n# \"dat -> F\" dataframe of equal protein sequences but differing protein accessions \n# \"F -> dat\" input dataframe plus protein sequence group and group size\ngetProteinSequenceGroup <- function(dat){\n  tmp <- unique(dat$proteinAccession)\n  tmp <- tmp[order(tmp)]\n  dat$proteinSequenceGroup <- paste(tmp, collapse = \" \")\n  dat$proteinSequenceGroupSize <- length(tmp)\n  return(dat)\n}\n\n# Reverses a character vector\n# \"vec -> F\" character vector\n# \"F -> dat\" vector with reversed character sequences\nreverseSequences <- function(vec){\n  vec_reversed <- strsplit(vec, split = \"\")\n  vec_reversed <- lapply(vec_reversed, rev)\n  vec_reversed <- lapply(vec_reversed, paste, collapse = \"\")\n  vec_reversed <- unlist(vec_reversed)\n  return(vec_reversed)\n}\n\npepToForm <- function(sequence){\n  if (!is.na(sequence)) {\n    peptideVector <- strsplit(sequence, split = \"\")[[1]]\n    FindElement <- function(residue){\n      element <- c(C = 0, H = 0, N = 0, O = 0, S = 0)\n      if (residue == \"A\") element <- c(C = 3, H = 5, N = 1, O = 1, S = 0)\n      if (residue == \"R\") element <- c(C = 6, H = 12, N = 4, O = 1, S = 0)\n      if (residue == \"N\") element <- c(C = 4, H = 6, N = 2, O = 2, S = 0)\n      if (residue == \"D\") element <- c(C = 4, H = 5, N = 1, O = 3, S = 0)\n      if (residue == \"C\") element <- c(C = 3, H = 5, N = 1, O = 1, S = 1)\n      if (residue == \"c\") element <- c(C = 5, H = 6, N = 2, O = 2, S = 1)\n      if (residue == \"E\") element <- c(C = 5, H = 7, N = 1, O = 3, S = 0)\n      if (residue == \"Q\") element <- c(C = 5, H = 8, N = 2, O = 2, S = 0)\n      if (residue == \"G\") element <- c(C = 2, H = 3, N = 1, O = 1, S = 0)\n      if (residue == \"H\") element <- c(C = 6, H = 7, N = 3, O = 1, S = 0)\n      if (residue == \"I\") element <- c(C = 6, H = 11, N = 1, O = 1, S = 0)\n      if (residue == \"L\") element <- c(C = 6, H = 11, N = 1, O = 1, S = 0)\n      if (residue == \"K\") element <- c(C = 6, H = 12, N = 2, O = 1, S = 0)\n      if (residue == \"M\") element <- c(C = 5, H = 9, N = 1, O = 1, S = 1)\n      if (residue == \"m\") element <- c(C = 5, H = 9, N = 1, O = 2, S = 1)\n      if (residue == \"F\") element <- c(C = 9, H = 9, N = 1, O = 1, S = 0)\n      if (residue == \"P\") element <- c(C = 5, H = 7, N = 1, O = 1, S = 0)\n      if (residue == \"S\") element <- c(C = 3, H = 5, N = 1, O = 2, S = 0)\n      if (residue == \"T\") element <- c(C = 4, H = 7, N = 1, O = 2, S = 0)\n      if (residue == \"W\") element <- c(C = 11, H = 10, N = 2, O = 1, S = 0)\n      if (residue == \"Y\") element <- c(C = 9, H = 9, N = 1, O = 2, S = 0)\n      if (residue == \"V\") element <- c(C = 5, H = 9, N = 1, O = 1, S = 0)\n      return(element)\n      }\n    resultsVector <- c(C = 0, H = 0, N = 0, O = 0, S = 0)\n    for (i in 1:length(peptideVector)) {\n      resultsVector <- FindElement(peptideVector[i]) + resultsVector\n      }\n    resultsVector <- resultsVector + c(C = 0, H = 2, N = 0, O = 1, S = 0)\n    result <- paste(\"C\",resultsVector[1],\"H\",resultsVector[2],\"N\",resultsVector[3],\"O\",resultsVector[4],\"S\",resultsVector[5])\n    return(result)\n    }\n  else return(NA)\n}\n\nreadLists <- function(directory){\n  \n  files <- list.files(path = directory)\n  files <- files[grep( \".csv\", files)]\n  \n  for (i in 1:length(files)) {\n    if (i == 1) {\n      dat <- read.csv(file = paste0(directory,files[i]))\n      dat <- unique(dat)\n      assayName <- factor(substr(files[i], 8 ,regexpr(pattern = \".csv\", files[i]) - 1))\n      dat$assay <- assayName\n    } \n    else {\n      x <- read.csv(file = paste0(directory,files[i]))\n      x <- unique(x)\n      assayName <- factor(substr(files[i], 8 ,regexpr(pattern = \".csv\", files[i]) - 1))\n      x$assay <- assayName\n      dat <- rbind(dat, x)\n    }  \n  }\n  \n  dat <- dat[order(dat[,1], dat[,2]),]\n  \n  return(dat)\n  \n}\n\nreadCsvDir <- function(directory){\n  \n  files <- list.files(path = directory)\n  files <- files[grep( \".csv\", files)]\n  \n  dat <- llply( files, function(x, dir) read.csv(file = paste0(dir,x), colClasses = \"character\"), directory, .progress = \"text\")\n  \n  return(dat)\n}\n\nsearchInputConvert <- function(dat, breakColumn = 15){\n  \n  peptideRows <- as.numeric(rownames(dat[ dat[,1] == \"\" ,]))\n  targetRows <- peptideRows - 1\n  lastColumn <- ncol(dat)\n  \n  dat[targetRows,breakColumn:lastColumn] <- dat[peptideRows, 2:(2 + lastColumn - breakColumn)]\n  \n  dat <- dat[ dat[,1] != \"\" ,]\n  \n  return(dat)\n}\n\n# # Writes all informations about each protein in *csv to disk\n# # \"dframe -> F\" dataframe containing a colum proteinAccession\n# # \"path -> F\" character with the path were the files should be written\n# # \"F -> NULL\" no return value \n# writeProtReports <- function(dframe, path = \"ProteinReports/\"){\n#   \n#   d_ply(dframe, .(proteinAccession), function(dframe_sub, path){\n#     \n#     filename <- paste0(format(Sys.time(), \"%y%m%d\"), \"-\", unique(dframe_sub$proteinAccession), \".csv\")\n#     dframe_sub <- dframe_sub[order(dframe_sub$start, dframe_sub$missedCleavages ),]\n#     write.csv(x = dframe_sub, file = paste0(path,filename), row.names = FALSE)\n#     \n#   }, path, .progress = \"text\")\n#   \n# }\n\n# Writes all informations about each protein in *csv to disk\n# \"dframe -> F\" dataframe containing a colum proteinAccession\n# \"path -> F\" character with the path were the files should be written\n# \"F -> NULL\" no return value \n\nwriteProtReports <- function(dframe1, dframe2, path = \"ProteinReports/\"){\n  \n  for (i in levels(dframe1$assay)) {\n    \n    print(i)\n    newpath <- paste0(path,i,\"/\")\n    dir.create(newpath)\n    protsOfAssay <- dframe1$accession[ dframe1$assay == i ]\n    subProteome <- dframe2[dframe2$proteinAccession %in% protsOfAssay,]\n    \n    d_ply(subProteome, .(proteinAccession), function(dframe_sub){\n    \n      filename <- paste0(format(Sys.time(), \"%y%m%d\"), \"-\", unique(dframe_sub$proteinAccession), \".csv\")\n      dframe_sub <- dframe_sub[order(dframe_sub$start, dframe_sub$missedCleavages ),]\n      write.csv(x = dframe_sub, file = paste0(newpath,filename), row.names = FALSE)\n    \n    }, .progress = \"text\")\n  }\n}\n\naddAssaysToProteome <- function(proteome, assayTargets){\n  \n  for (i in levels(assayTargets$assay)) {\n    \n    proteome[,i] <- proteome$proteinAccession %in% assayTargets$accession[ assayTargets$assay == i ]\n    \n  }\n    \n  return(proteome)\n}\n\ncomputeScheduling <- function(dat, rtSec = \"retentionTime\", windowWidthMin = 7){\n  \n  dat$start <- dat[rtSec] - (windowWidthMin / 2 * 60)\n  dat$stop <- dat[rtSec] + (windowWidthMin / 2 * 60)\n  \n  if (all(is.na(dat$start))) {\n    dat$start <- 0\n    dat$stop <- 120\n  }\n  else {\n    dat$start[ is.na(dat$start)] <- min(dat$start[ !is.na(dat$start)])\n    dat$stop[ is.na(dat$stop)] <- max(dat$stop[ !is.na(dat$stop)])\n  }\n  \n  x <- seq( from = min(dat$start), to = max(dat$stop), by = 1)\n  y <- sapply(x, function(a,b){sum( a >= b$start & a <= b$stop)}, dat)\n  \n  scheduling <- data.frame(\n    retentionTime = x,\n    concurrentPrecursors = y\n  )\n  \n  return(scheduling)\n}\n\nplotScheduling_IncList <- function(file){\n  \n  x <- read.csv(file)\n  \n  if (all(is.na(x[\"Start..min.\"]))) {\n    x$Start..min. <- 0\n    x$End..min. <- 120\n  }\n  else {\n    x[ is.na(x[\"Start..min.\"]), \"Start..min.\"] <- min(x[ !is.na(x[\"Start..min.\"]), \"Start..min.\"])\n    x[ is.na(x[\"End..min.\"]), \"End..min.\"] <- max(x[ !is.na(x[\"End..min.\"]), \"End..min.\"])\n  }\n  \n  y <- seq( from = min(x[\"Start..min.\"] - 1), to = max(x[\"End..min.\"] + 1), by = 1/60)\n  \n  scheduling <- data.frame(\n    RetentionTime = y,\n    ConcurrentPrecursors = sapply(y, function(a,b){sum( a >= b[\"Start..min.\"] & a <= b[\"End..min.\"])}, x)\n  )\n  \n  print(ggplot(scheduling, aes(RetentionTime, ConcurrentPrecursors)) + geom_step())\n}\n\nsplitPlotSave_IncList <- function(file, split, double){\n  \n  x <- read.csv(file)\n  \n  iRTPeps <- c(\n    \"TAFLLLTLK (light)\" , \n    \"TLALELGYIPVLTK (light)\",\n    \"VLPIDYSLSILK (light)\",\n    \"YVLIFVLPLETR (light)\",\n    \"ISTEKGVALPHK (light)\",\n    \"LLVLYGLR (light)\",\n    \"VLVLGGGVLGR (light)\",\n    \"LLATLKLSK (light)\",\n    \"TLPLELVIR (light)\",\n    \"TTLLKLIIK (light)\",\n    \"HDSIDNNAHSHLR (light)\",\n    \"LVIILYAFK (light)\",\n    \"IAPIILR (light)\",\n    \"LLLAKPIR (light)\",\n    \"TALIFLVR (light)\",\n    \"KPFQLSTGLKR (light)\"\n  )\n  \n  iRT <- x[ x$Comment %in% iRTPeps,]\n  x <- x[ !(x$Comment %in% iRTPeps),]\n  \n  x <- x[order( x$Start..min. ),]\n  \n  part <- rep(1:split, (nrow(x)/split) + 1 )\n  x$part <- part[1:nrow(x)]\n  \n  for (i in 1:split) {\n    \n    sub <- x[ x$part == i, names(x) != \"part\" ]\n    \n    if (double == TRUE) {\n      sub <- rbind(sub, iRT)\n      sub <- rbind(sub, sub)\n      sub <- sub[order(sub$Comment),]\n    }\n    else {\n      sub <- rbind(sub, iRT)\n    }\n    \n    if (all(is.na(sub[\"Start..min.\"]))) {\n      sub$Start..min. <- 0\n      sub$End..min. <- 120\n    }\n    else {\n      sub[ is.na(sub[\"Start..min.\"]), \"Start..min.\"] <- min(sub[ !is.na(sub[\"Start..min.\"]), \"Start..min.\"])\n      sub[ is.na(sub[\"End..min.\"]), \"End..min.\"] <- max(sub[ !is.na(sub[\"End..min.\"]), \"End..min.\"])\n    }\n    \n    y <- seq( from = min(sub[\"Start..min.\"] - 1), to = max(sub[\"End..min.\"] + 1), by = 1/60)\n    \n    scheduling <- data.frame(\n      RetentionTime = y,\n      ConcurrentPrecursors = sapply(y, function(a,b){sum( a >= b[\"Start..min.\"] & a <= b[\"End..min.\"])}, sub)\n    )\n    \n    print(ggplot(scheduling, aes(RetentionTime, ConcurrentPrecursors)) + geom_step())\n    \n    colnames(sub) <- c(\"Mass [m/z]\", \"Formula [M]\", \"Species\", \"CS [z]\", \"Polarity\", \"Start [min]\", \"End [min]\", \"NCE\", \"Comment\")\n    write.csv(sub, paste0(sub(\".csv\",\"\", file),\"-part\",i,\".csv\"), row.names = FALSE, na = \"\" )\n  }\n}\n\nunschedule <- function(x, iRTPeps) {\n  \n  x$Start..min. <- with(x, ifelse(!(Comment %in% iRTPeps), NA , Start..min.))\n  x$End..min. <- with(x, ifelse(!(Comment %in% iRTPeps), NA , End..min.))\n  return(x)\n  \n}\n\ntopX <- function(dframe, value, X){\n  ord <- order(dframe[,value], decreasing = TRUE)\n  if (length(ord) < X) X <- length(ord) \n  top <- ord[1:X]\n  dframe <- dframe[top,]\n  return(dframe)\n}\n\nalignCountErrors <- function(a,b,c){\n  if (is.na(c)) return(NA)\n  if (c == 5) return( min( c( # a longer b, 6 possibilities\n    sum(a[1:(length(a) - 5)] != b ),\n    sum(a[2:(length(a) - 4)] != b ),\n    sum(a[3:(length(a) - 3)] != b ),\n    sum(a[4:(length(a) - 2)] != b ),\n    sum(a[5:(length(a) - 1)] != b ),\n    sum(a[6:(length(a) - 0)] != b )\n  )) + abs(c) )\n  if (c == 4) return( min( c( # 5 possibilities\n    sum(a[1:(length(a) - 4)] != b ),\n    sum(a[2:(length(a) - 3)] != b ),\n    sum(a[3:(length(a) - 2)] != b ),\n    sum(a[4:(length(a) - 1)] != b ),\n    sum(a[5:(length(a) - 0)] != b )\n  )) + abs(c) )\n  if (c == 3) return( min( c( # 4 possibilities\n    sum(a[1:(length(a) - 3)] != b ),\n    sum(a[2:(length(a) - 2)] != b ),\n    sum(a[3:(length(a) - 1)] != b ),\n    sum(a[4:(length(a) - 0)] != b )\n  )) + abs(c) )\n  if (c == 2) return( min( c( # 3 possibilities\n    sum(a[1:(length(a) - 2)] != b ),\n    sum(a[2:(length(a) - 1)] != b ),\n    sum(a[3:(length(a) - 0)] != b )\n  )) + abs(c) )\n  if (c == 1) return( min( c( # 2 possibilities\n    sum(a[1:(length(a) - 1)] != b ),\n    sum(a[2:(length(a) - 0)] != b )\n  )) + abs(c) )\n  if (c == 0) return( sum(a != b) ) \n  if (c == -1) return( min( c(\n    sum(a != b[1:(length(b) - 1)] ),\n    sum(a != b[2:(length(b) - 0)] )\n  )) + abs(c) )\n  if (c == -2)  return( min( c(\n    sum(a != b[1:(length(b) - 2)] ),\n    sum(a != b[2:(length(b) - 1)] ),\n    sum(a != b[3:(length(b) - 0)] )\n  )) + abs(c) )\n  if (c == -3) return( min( c(\n    sum(a != b[1:(length(b) - 3)] ),\n    sum(a != b[2:(length(b) - 2)] ),\n    sum(a != b[3:(length(b) - 1)] ),\n    sum(a != b[4:(length(b) - 0)] )\n  )) + abs(c) )\n  if (c == -4) return( min( c(\n    sum(a != b[1:(length(b) - 4)] ),\n    sum(a != b[2:(length(b) - 3)] ),\n    sum(a != b[3:(length(b) - 2)] ),\n    sum(a != b[4:(length(b) - 1)] ),\n    sum(a != b[5:(length(b) - 0)] )\n  )) + abs(c) )\n  if (c == -5) return( min( c(\n    sum(a != b[1:(length(b) - 5)] ),\n    sum(a != b[2:(length(b) - 4)] ),\n    sum(a != b[3:(length(b) - 3)] ),\n    sum(a != b[4:(length(b) - 2)] ),\n    sum(a != b[5:(length(b) - 1)] ),\n    sum(a != b[6:(length(b) - 0)] )\n  )) + abs(c) )\n  else return(NA)\n}\n\nfindFirstErrorPosition <- function(a,b){\n  if (length(a) == length(b) & !is.na(a) & !is.na(b)){\n    c <- a == b\n    d <- 1:length(a)\n    if (sum(c) != length(a)){\n      d <- d[!(c)]\n      d <- d[1]\n      return(d)\n    }\n    if (sum(c) == length(a)){\n      return(0)\n    }\n  }\n  if (length(a) != length(b) & !is.na(a) & !is.na(b)){return(-1)}\n  else return(NA)\n}\n",
    "created" : 1486418776645.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2685178546",
    "id" : "9B1AD98E",
    "lastKnownWriteTime" : 1457712765,
    "last_content_update" : 1457712765,
    "path" : "~/Zotero/storage/QAB5B8EJ/Functions.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}